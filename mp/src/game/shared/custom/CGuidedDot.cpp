#include "cbase.h"
#include "CGuidedDot.h"

IMPLEMENT_NETWORKCLASS_ALIASED(GuidedDot, DT_GuidedDot)

BEGIN_NETWORK_TABLE(CGuidedDot, DT_GuidedDot)
#ifdef CLIENT_DLL
RecvPropBool(RECVINFO(m_bIsOn)),
#else
SendPropBool(SENDINFO(m_bIsOn)),
#endif
END_NETWORK_TABLE()

#ifndef CLIENT_DLL
// a list of laser dots to search quickly
CEntityClassList<CGuidedDot> g_LaserDotList;
template <> CGuidedDot *CEntityClassList<CGuidedDot>::m_pClassList = NULL;
CGuidedDot *GetLaserDotList()
{
	return g_LaserDotList.m_pClassList;
}

#endif

LINK_ENTITY_TO_CLASS(guided_dot, CGuidedDot);

BEGIN_DATADESC(CGuidedDot)
DEFINE_FIELD(m_vecSurfaceNormal, FIELD_VECTOR),
DEFINE_FIELD(m_hTargetEnt, FIELD_EHANDLE),
DEFINE_FIELD(m_bVisibleLaserDot, FIELD_BOOLEAN),
DEFINE_FIELD(m_bIsOn, FIELD_BOOLEAN),

//DEFINE_FIELD( m_pNext, FIELD_CLASSPTR ),	// don't save - regenerated by constructor
END_DATADESC()


//-----------------------------------------------------------------------------
// Finds missiles in cone
//-----------------------------------------------------------------------------
CBaseEntity *CreateDot(const Vector &origin, CBaseEntity *pOwner, bool bVisibleDot)
{
	return CGuidedDot::Create(origin, pOwner, bVisibleDot);
}

void SetDotTarget(CBaseEntity *pLaserDot, CBaseEntity *pTarget)
{
	CGuidedDot *pDot = assert_cast<CGuidedDot*>(pLaserDot);
	pDot->SetTargetEntity(pTarget);
}

void EnableDot(CBaseEntity *pLaserDot, bool bEnable)
{
	CGuidedDot *pDot = assert_cast<CGuidedDot*>(pLaserDot);
	if (bEnable)
	{
		pDot->TurnOn();
	}
	else
	{
		pDot->TurnOff();
	}
}

CGuidedDot::CGuidedDot(void)
{
	m_hTargetEnt = NULL;
	m_bIsOn = true;
#ifndef CLIENT_DLL
	g_LaserDotList.Insert(this);
#endif
}

CGuidedDot::~CGuidedDot(void)
{
#ifndef CLIENT_DLL
	g_LaserDotList.Remove(this);
#endif
}


//-----------------------------------------------------------------------------
// Purpose: 
// Input  : &origin - 
// Output : CGuidedDot
//-----------------------------------------------------------------------------
CGuidedDot *CGuidedDot::Create(const Vector &origin, CBaseEntity *pOwner, bool bVisibleDot)
{
#ifndef CLIENT_DLL
	//	CGuidedDot *pLaserDot = (CGuidedDot *) CBaseEntity::Create( "guided_dot", origin, QAngle(0,0,0) );

		//idk if this is alright...
	CGuidedDot *pLaserDot = assert_cast<CGuidedDot*>(CBaseEntity::Create("guided_dot", origin, vec3_angle));

	if (pLaserDot == NULL)
		return NULL;

	pLaserDot->m_bVisibleLaserDot = bVisibleDot;
	pLaserDot->SetMoveType(MOVETYPE_NONE);
	pLaserDot->AddSolidFlags(FSOLID_NOT_SOLID);
	pLaserDot->AddEffects(EF_NOSHADOW);
	pLaserDot->SetSize(-vec3_origin, vec3_origin);
	pLaserDot->m_nRenderMode = kRenderWorldGlow;
	pLaserDot->m_nRenderFX = kRenderFxNoDissipation;

	pLaserDot->SetOwnerEntity(pOwner);

	pLaserDot->AddEFlags(EFL_FORCE_CHECK_TRANSMIT);

	return pLaserDot;
#else
	return NULL;
#endif
}

void CGuidedDot::SetDotPosition(const Vector &origin, const Vector &normal)
{
	SetAbsOrigin(origin);
	m_vecSurfaceNormal = normal;
}

Vector CGuidedDot::GetChasePosition()
{
	return GetAbsOrigin() - m_vecSurfaceNormal * 10;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CGuidedDot::TurnOn(void)
{
	m_bIsOn = true;
	RemoveEffects(EF_NODRAW);

	if (m_bVisibleLaserDot)
	{
		//BaseClass::TurnOn();
	}
}


//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CGuidedDot::TurnOff(void)
{
	m_bIsOn = false;
	AddEffects(EF_NODRAW);
}


#ifdef CLIENT_DLL

//-----------------------------------------------------------------------------
// Purpose: Draw our sprite
//-----------------------------------------------------------------------------
int CGuidedDot::DrawModel(int flags)
{
	color32 color = { 255, 255, 255, 255 };
	Vector	vecAttachment, vecDir, vecLenght;
	QAngle	angles;

	float	scale;
	Vector	endPos;

	CBasePlayer *pOwner = ToBasePlayer(GetOwnerEntity());	//CHL1MP_PLAYER

	if (pOwner != NULL && pOwner->IsDormant() == false)
	{
		// Always draw the dot in front of our faces when in first-person
		if (pOwner->IsLocalPlayer())
		{
			// Take our view position and orientation
			vecAttachment = CurrentViewOrigin();
			vecDir = CurrentViewForward();
		}
		else
		{
			// Take the eye position and direction
			vecAttachment = pOwner->EyePosition();

			QAngle angles = pOwner->EyeAngles();
			AngleVectors(angles, &vecDir);
		}

		trace_t tr;
		UTIL_TraceLine(vecAttachment, vecAttachment + (vecDir * MAX_TRACE_LENGTH), MASK_SHOT, pOwner, COLLISION_GROUP_NONE, &tr);

		// Backup off the hit plane
		endPos = tr.endpos - (vecDir * 10);
	}
	else
	{
		// Just use our position if we can't predict it otherwise
		endPos = GetAbsOrigin();
	}

	//get our lenght vector
	vecLenght = vecAttachment - endPos;

	if (pOwner && pOwner->IsLocalPlayer())
	{
		scale = (vecLenght.Length() / 2) * 0.05f + RandomFloat(-0.5f, 0.5f);
		scale = Clamp(scale, 0.1f, 32.0f);
	}
	else
		scale = 8.0f + RandomFloat(-4.0f, 4.0f); //12.0f before

	DevWarning("Dot's scale is -->%g\n", scale);

	// Draw our laser dot in space
	CMatRenderContextPtr pRenderContext(materials);
	pRenderContext->Bind(m_hSpriteMaterial, this);
	DrawSprite(endPos, scale, scale, color);

	return 1;
}
//-----------------------------------------------------------------------------
// Purpose: Setup our sprite reference
//-----------------------------------------------------------------------------
void CGuidedDot::OnDataChanged(DataUpdateType_t updateType)
{
	if (updateType == DATA_UPDATE_CREATED)
	{
		m_hSpriteMaterial.Init(RPG_LASER_SPRITE, TEXTURE_GROUP_CLIENT_EFFECTS);
	}
}

#endif	//CLIENT_DLL